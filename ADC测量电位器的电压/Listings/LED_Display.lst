C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       02/05/2026 14:14:00 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LED_DISPLAY
OBJECT MODULE PLACED IN .\Objects\LED_Display.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE LED_Display.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\LED_Display.lst) OBJECT(.\Objects\LED_Display.obj)

line level    source

   1          #include <stc15f2k60s2.h>
   2          #include "LED.h"
   3          #include "Delay.h"
   4          #include "PCF8591.h"
   5          #include "IIC.h"
   6          #include "Uart.h"
   7          #include "Common.h"
   8          
   9          code unsigned char SEG_Table[] = {
  10                  0xC0,   //0
  11                  0xF9,   //1
  12                  0xA4,   //2
  13                  0xB0,   //3
  14                  0x99,   //4
  15                  0x92,   //5
  16                  0x82,   //6
  17                  0xF8,   //7
  18                  0x80,   //8
  19                  0x90,   //9
  20                  0xFF,   //全灭
  21                  0xC1    //U
  22          };
  23          
  24          //RB2存储数组1
  25          unsigned char RB2_dat_arr1[] = {11,10,10,10,10,10,10,10};
  26          //RB2存储数组2
  27          unsigned char RB2_dat_arr2[] = {11,10,10,10,10,10,10,10};
  28          //RB2存储数组3
  29          unsigned char RB2_dat_arr3[] = {11,10,10,10,10,10,10,10};
  30          //RB2显示数组
  31          unsigned char RB2_dat[] = {11,10,10,10,10,10,10,10};
  32          //数码管显示选择变量
  33          unsigned char LED_Display_flag = 0;
  34          
  35          //RB2存储数组1转化函数
  36          void RB2_arr1_Change(){
  37   1              float RB2_value = RB2_Value();
  38   1              unsigned int RB2 = (unsigned int)(RB2_value * 50);
  39   1              unsigned char i;
  40   1              if(RB2 >= 10){
  41   2                      RB2_dat_arr1[6] = RB2 / 10;
  42   2                      RB2_dat_arr1[7] = RB2 % 10;
  43   2              }
  44   1              else if(RB2 < 10 && RB2 >= 0){
  45   2                      RB2_dat_arr1[6] = 0;
  46   2                      RB2_dat_arr1[7] = RB2 % 10;
  47   2              }
  48   1              for(i = 0;i < 8;i++){
  49   2                      RB2_dat[i] = RB2_dat_arr1[i];
  50   2              }
  51   1      }
  52          
  53          //RB2存储数组2转化函数
  54          void RB2_arr2_Change(){
C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       02/05/2026 14:14:00 PAGE 2   

  55   1              float RB2_value = RB2_Value();
  56   1              unsigned int RB2 = (unsigned int)(RB2_value * 500);
  57   1              unsigned char i;
  58   1              if(RB2 >= 100){
  59   2                      RB2_dat_arr2[5] = RB2 / 100;
  60   2                      RB2_dat_arr2[6] = RB2 % 100 / 10;
  61   2                      RB2_dat_arr2[7] = RB2 % 10;
  62   2              }
  63   1              else if(RB2 < 100 && RB2 >= 10){
  64   2                      RB2_dat_arr2[5] = 0;
  65   2                      RB2_dat_arr2[6] = RB2 / 10;
  66   2                      RB2_dat_arr2[7] = RB2 % 10;
  67   2              }
  68   1              else if(RB2 < 10 && RB2 >= 0){
  69   2                      RB2_dat_arr2[5] = 0;
  70   2                      RB2_dat_arr2[6] = 0;
  71   2                      RB2_dat_arr2[7] = RB2 % 10;
  72   2              }
  73   1              for(i = 0;i < 8;i++){
  74   2                      RB2_dat[i] = RB2_dat_arr2[i];
  75   2              }
  76   1      }
  77          
  78          //RB2存储数组3转化函数
  79          void RB2_arr3_Change(){
  80   1              float RB2_value = RB2_Value();
  81   1              unsigned int RB2 = (unsigned int)(RB2_value * 5);
  82   1              unsigned char i;
  83   1              RB2_dat_arr3[7] = RB2;
  84   1              for(i = 0;i < 8;i++){
  85   2                      RB2_dat[i] = RB2_dat_arr3[i];
  86   2              }
  87   1      }
  88          
  89          //串口数据处理函数
  90          unsigned char Uart_Choose(){
  91   1              unsigned char *recv_dat = Recv_dat_arr();
  92   1              unsigned char i;
  93   1              unsigned char dat = 3;
  94   1              for(i = 0;i < 6;i++){
  95   2                      if(recv_dat[i] == 'a' || recv_dat[i] == 'A'){
  96   3                              dat = 1;
  97   3                              break;
  98   3                      }
  99   2                      if(recv_dat[i] == '1' || recv_dat[i] == '#'){
 100   3                              dat = 2;
 101   3                              break;
 102   3                      }
 103   2              }
 104   1              return dat;
 105   1      }
 106          
 107          //数码管显示选择数组
 108          void LED_Display_Choose(){
 109   1              if(LED_Display_flag == 1){
 110   2                      RB2_arr1_Change();
 111   2                      LED(LED_Table[0]);
 112   2              }       
 113   1              if(LED_Display_flag == 2){
 114   2                      RB2_arr2_Change();
 115   2                      LED(LED_Table[1]);
 116   2              }               
C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       02/05/2026 14:14:00 PAGE 3   

 117   1              if(LED_Display_flag == 3){
 118   2                      RB2_arr3_Change();
 119   2                      LED(LED_Table[2]);
 120   2              }       
 121   1      }
 122          
 123          //数码管显示数组
 124          void LED_Display_Show(){
 125   1              unsigned char com;
 126   1              unsigned char dat;
 127   1              for(com = 0;com < 8;com++){
 128   2                      SEG(0xFF);
 129   2                      COM(1<<com);
 130   2                      dat = SEG_Table[RB2_dat[com]];
 131   2                      if(LED_Display_flag == 1 && com == 6){
 132   3                              dat = dat & 0x7F;
 133   3                      }
 134   2                      if(LED_Display_flag == 2 && com == 5){
 135   3                              dat = dat & 0x7F;
 136   3                      }
 137   2                      SEG(dat);
 138   2                      Delay50us();
 139   2              }
 140   1              COM(0xFF);
 141   1              SEG(0xFF);
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    608    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
