C51 COMPILER V9.60.7.0   UART                                                              01/22/2026 13:56:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\Uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\Uart
                    -.lst) OBJECT(.\Objects\Uart.obj)

line level    source

   1          #include <stc15f2k60s2.h>
   2          #define BAUD         9600   // 串口波特率
   3          #define SYSTEMCLOCK  12000000L  // 系统时钟频率
   4          
   5          unsigned char rx_buf[1] = {0};    
   6          unsigned char rx_cnt = 0;         // 接收字符计数
   7          bit rx_complete_flag = 0;         // 接收完成标志
   8          
   9          
  10          // 系统初始化函数
  11          void system_init(void)
  12          {
  13   1          // 串口初始化
  14   1          SCON = 0x50;          // 8位数据,可变波特率,REN=1允许接收
  15   1          AUXR = 0x40;          // 定时器1使用1T模式(STC15专属)
  16   1          TMOD = 0x00;          // 定时器1为16位自动重装模式
  17   1          // 计算定时器1初值(9600波特率)
  18   1          TL1 = (65536 - (SYSTEMCLOCK / 4 / BAUD));
  19   1          TH1 = (65536 - (SYSTEMCLOCK / 4 / BAUD)) >> 8;
  20   1          TR1 = 1;              // 启动定时器1
  21   1          ES = 1;               // 使能串口中断
  22   1          EA = 1;               // 使能总中断
  23   1      }
  24          
  25          
  26          // 串口发送字符串
  27          void uart_sendstring(unsigned char *str)
  28          {
  29   1          unsigned char *p = str;
  30   1          while(*p != '\0')  // 遍历字符串直到结束符
  31   1          {
  32   2              SBUF = *p;     // 写入当前字符到发送寄存器
  33   2              while(TI == 0); // 等待发送完成
  34   2              TI = 0;        // 清发送中断标志
  35   2              p++;           // 指向下一个字符
  36   2          }
  37   1      }
  38          
  39          void isr_uart(void) interrupt 4
  40          {
  41   1          if(RI)
  42   1          {
  43   2              RI = 0;  // 清接收中断标志
  44   2              if(rx_cnt < 1)  // 只接收1个字符
  45   2              {
  46   3                  rx_buf[rx_cnt] = SBUF;  // 存储接收字符
  47   3                  rx_cnt++;               // 计数+1
  48   3                  if(rx_cnt == 1)         // 1个字符接收完成 
  49   3                  {
  50   4                      rx_complete_flag = 1;    // 置接收完成标志
  51   4                  }
  52   3              }
  53   2              else
  54   2              {
C51 COMPILER V9.60.7.0   UART                                                              01/22/2026 13:56:06 PAGE 2   

  55   3                  // 超出1个字符，重置缓冲区
  56   3                  rx_cnt = 0;
  57   3                  rx_buf[0] = 0;  
  58   3              }
  59   2          }
  60   1          // 增加发送中断标志清零，避免干扰
  61   1          if(TI)
  62   1          {
  63   2              TI = 0;
  64   2          }
  65   1      }
  66          
  67          unsigned char *Arr_Value(){
  68   1          if(rx_complete_flag)
  69   1          {
  70   2              return rx_buf;  // 接收完成返回缓冲区地址
  71   2          }
  72   1      }
  73                  
  74          
  75          
  76          
*** WARNING C291 IN LINE 72 OF Uart.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    111    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
