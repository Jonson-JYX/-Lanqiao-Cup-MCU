C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       01/25/2026 21:57:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LED_DISPLAY
OBJECT MODULE PLACED IN .\Objects\LED_Display.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE LED_Display.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\LED_Display.lst) OBJECT(.\Objects\LED_Display.obj)

line level    source

   1          #include <stc15f2k60s2.h>
   2          #include "KEY.h"
   3          #include "DS18B20.h"
   4          #include "Delay.h"
   5          #include "Common.h"
   6          
   7          
   8          code unsigned char LED_Display_Table[] = {
   9                  0xC0,   // 0
  10                  0xF9,   // 1
  11                  0xA4,   // 2
  12                  0xB0,   // 3
  13                  0x99,   // 4
  14                  0x92,   // 5
  15                  0x82,   // 6
  16                  0xF8,   // 7
  17                  0x80,   // 8
  18                  0x90,   // 9
  19                  0xC6,   // C
  20                  0xFF,   // 全灭
  21          };
  22          
  23          //模式一温度显示数组
  24          unsigned char Temp_modle1_Arr[] = {11,11,11,11,11,11,11,10};
  25          
  26          //模式二温度显示数组
  27          unsigned char Temp_modle2_Arr[] = {11,11,11,11,11,11,11,10};
  28          
  29          //温度存储显示数组
  30          unsigned char Temp_dat[] = {11,11,11,11,11,11,11,10};
  31          
  32          //转换温度函数
  33          void Temp_Change(){
  34   1              float temp = Temp_Value();
  35   1              unsigned int temp_modle1 = (unsigned int)(temp * 10);
  36   1              unsigned int temp_modle2 = (unsigned int)(temp * 100);
  37   1              
  38   1              //模式一存储
  39   1              if(temp_modle1 >= 1000){
  40   2                      Temp_modle1_Arr[3] = temp_modle1 / 1000;
  41   2                      Temp_modle1_Arr[4] = temp_modle1 % 1000 / 100;
  42   2                      Temp_modle1_Arr[5] = temp_modle1 % 100 / 10;
  43   2                      Temp_modle1_Arr[6] = temp_modle1 % 10;
  44   2              }
  45   1              else if(temp_modle1 >= 100 && temp_modle1 < 1000){
  46   2                      Temp_modle1_Arr[3] = 11;
  47   2                      Temp_modle1_Arr[4] = temp_modle1 / 100;
  48   2                      Temp_modle1_Arr[5] = temp_modle1 % 100 / 10;
  49   2                      Temp_modle1_Arr[6] = temp_modle1 % 10;
  50   2              }
  51   1              else if(temp_modle1 >= 10 && temp_modle1 < 100){
  52   2                      Temp_modle1_Arr[3] = 11;
  53   2                      Temp_modle1_Arr[4] = 11;
  54   2                      Temp_modle1_Arr[5] = temp_modle1 / 10;
C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       01/25/2026 21:57:58 PAGE 2   

  55   2                      Temp_modle1_Arr[6] = temp_modle1 % 10;
  56   2              }
  57   1              else if(temp_modle1 < 10){
  58   2                      Temp_modle1_Arr[3] = 11;
  59   2                      Temp_modle1_Arr[4] = 11;
  60   2                      Temp_modle1_Arr[5] = 0;
  61   2                      Temp_modle1_Arr[6] = temp_modle1 % 10;
  62   2              }
  63   1              
  64   1              //模式二存储
  65   1              if(temp_modle2 >= 10000){
  66   2                      Temp_modle2_Arr[2] = temp_modle2 / 10000;
  67   2                      Temp_modle2_Arr[3] = temp_modle2 % 10000 / 1000;
  68   2                      Temp_modle2_Arr[4] = temp_modle2 % 1000 / 100;
  69   2                      Temp_modle2_Arr[5] = temp_modle2 % 100 / 10;
  70   2                      Temp_modle2_Arr[6] = temp_modle2 % 10;
  71   2              }
  72   1              else if(temp_modle2 >= 1000 && temp_modle2 < 10000){
  73   2                      Temp_modle2_Arr[2] = 11;
  74   2                      Temp_modle2_Arr[3] = temp_modle2 / 1000;
  75   2                      Temp_modle2_Arr[4] = temp_modle2 % 1000 / 100;
  76   2                      Temp_modle2_Arr[5] = temp_modle2 % 100 / 10;
  77   2                      Temp_modle2_Arr[6] = temp_modle2 % 10;
  78   2              }
  79   1              else if(temp_modle2 >= 100 && temp_modle2 < 1000){
  80   2                      Temp_modle2_Arr[2] = 11;
  81   2                      Temp_modle2_Arr[3] = 11;
  82   2                      Temp_modle2_Arr[4] = temp_modle2 / 100;
  83   2                      Temp_modle2_Arr[5] = temp_modle2 % 100 / 10;
  84   2                      Temp_modle2_Arr[6] = temp_modle2 % 10;
  85   2              }
  86   1              else if(temp_modle2 >= 10 && temp_modle2 < 100){
  87   2                      Temp_modle2_Arr[2] = 11;
  88   2                      Temp_modle2_Arr[3] = 11;
  89   2                      Temp_modle2_Arr[4] = 0;
  90   2                      Temp_modle2_Arr[5] = temp_modle2 / 10;
  91   2                      Temp_modle2_Arr[6] = temp_modle2 % 10;
  92   2              }
  93   1              else if(temp_modle2 < 10){
  94   2                      Temp_modle2_Arr[2] = 11;
  95   2                      Temp_modle2_Arr[3] = 11;
  96   2                      Temp_modle2_Arr[4] = 0;
  97   2                      Temp_modle2_Arr[5] = 0;
  98   2                      Temp_modle2_Arr[6] = temp_modle2 % 10;
  99   2              }
 100   1      }
 101          
 102          //数码管显示函数
 103          void LED_Display_Show(){
 104   1              unsigned char i;
 105   1              unsigned char dat;
 106   1              unsigned char com = 0;
 107   1              
 108   1              for(i = 0;i < 8;i++){
 109   2                      COM(0xff);
 110   2                      SEG(0xff);
 111   2                      COM(1<<com);
 112   2                      dat = LED_Display_Table[Temp_dat[i]];
 113   2                      if(key_password == 0 && i == 5){
 114   3                              dat = (LED_Display_Table[Temp_dat[i]]) & 0x7F;
 115   3                      }
 116   2                      if(key_password == 1 && i == 4){
C51 COMPILER V9.60.7.0   LED_DISPLAY                                                       01/25/2026 21:57:58 PAGE 3   

 117   3                              dat = (LED_Display_Table[Temp_dat[i]]) & 0x7F;
 118   3                      }
 119   2                      SEG(dat);
 120   2                      com++;
 121   2                      Delay40us();
 122   2              }
 123   1              com = 0;
 124   1              COM(0xff);
 125   1              SEG(0xff);
 126   1      }
 127          
 128          //数码管模式选择函数
 129          void LED_Display_Choose(){
 130   1              unsigned char i;
 131   1              if(key_password == 0){
 132   2                      for(i = 0;i < 8;i++){
 133   3                              Temp_dat[i] = Temp_modle1_Arr[i];
 134   3                      }
 135   2              }
 136   1              if(key_password == 1){
 137   2                      for(i = 0;i < 8;i++){
 138   3                              Temp_dat[i] = Temp_modle2_Arr[i];
 139   3                      }
 140   2              }
 141   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    690    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
